# Intersection Density.sage

# this file uses results from all three ekr properties to compute upper and lower bounds
# on the intersection density of a group, as well as an exact value if it is known.

class Intersection_Density:
    def __init__(self, G, ekr_determiner, ekrm_determiner):
        self.G = G
        self.has_ekr = ekr_determiner.has_ekr
        self.upper_bound = self._get_upper_bound()
        self.lower_bound = self._get_lower_bound()
        self.exact_value = self._get_exact_value()

    def _get_upper_bound(self):
        if self.has_ekr:   
            return 1
        if len(self.G.larger_than_stabilizer_cocliques) >= 1: 
            # we have at least one subgroup which is larger than the stabilizer of a point, so
            # gather all subgroups with size larger than stabilizer in a list, and compute its size:
            size = max([subgroup.order() for subgroup in self.G.larger_than_stabilizer_cocliques])
            # use the largest order (size) to calculate an upper bound on intersection density:
            return size / (self.G.size_of_stabilizer)
        # CLIQUE/COCLIQUE
        else:
            largest_clique_size = -1  #initializing variable

            for subgroup_cc in self.G.subgroups: #remember, G.subgroups gives conjugacy classes

                if subgroup_cc.representative().order() <= self.G.order:
                    for subgroup in subgroup_cc:
                        sub_common = Common(subgroup)
                        if sub_common.min_eigenvalue == -1 and sub_common.order > largest_clique_size:
                            largest_clique_size = sub_common.order
                            
            return largest_clique_size

        return -1 # testing

    def _get_lower_bound(self):
        return 1 #1 is the lowest we can get.

    def _get_exact_value(self):
        if self.upper_bound == self.lower_bound:
            return self.upper_bound
        if self.G.is_a_complete_multipartite:
            # then intersection density is -(tau)/(size_of_stabilizer)
                tau = gap.AbsoluteValue(self.G.min_eigenvalue)

                # exact value is found using least eigenvalue
                self.upper_bound = tau / (self.G.size_of_stabilizer)
                self.lower_bound = tau / (self.G.size_of_stabilizer)
                return tau / (self.G.size_of_stabilizer)

        if self.G.is_a_join:
            # then reduce to the subgroup generated by the non-derangements
            non_derangements = [] # holds all non-derangement elements of G
            for c in self.G.conjugacy_classes: 
                if not Permutation(c.representative()).is_derangement():
                    for element in c:
                        non_derangements.append(element)
            H = PermutationGroup(non_derangements)
            non_der_common = Common(H)
            non_der_ekr = EKR_Determiner(non_der_common)
            #if non_der_ekr.has_ekr:
                #return 1
        return -1