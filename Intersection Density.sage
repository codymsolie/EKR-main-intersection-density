# Intersection Density.sage

# this file uses results from all three ekr properties to compute upper and lower bounds
# on the intersection density of a group, as well as an exact value if it is known.

class Intersection_Density:
    def __init__(self, G, ekr_determiner, ekrm_determiner):
        self.G = G
        self.has_ekr = ekr_determiner.has_ekr
        self.upper_bound = self._get_upper_bound()
        self.lower_bound = self._get_lower_bound()
        self.exact_value = self._get_exact_value()

    def _get_upper_bound(self):
      return max(
        int(self.has_ekr),
        int(self.ub_larger_than_stabilizer_cocliques(self.G)),
        int(self.ub_clique_coclique(self.G)),
        int(self.ub_no_homomorphism(self.G))
      )
    def _get_lower_bound(self):
        return 1 #1 is the lowest we can get.

    def _get_exact_value(self):
        if self.upper_bound == self.lower_bound:
            return self.upper_bound
        if self.G.is_a_complete_multipartite:
            # then intersection density is -(tau)/(size_of_stabilizer)
                tau = gap.AbsoluteValue(self.G.min_eigenvalue)

                # exact value is found using least eigenvalue
                self.upper_bound = tau / (self.G.size_of_stabilizer)
                self.lower_bound = tau / (self.G.size_of_stabilizer)
                return tau / (self.G.size_of_stabilizer)

        if self.G.is_a_join:
            # then reduce to the subgroup generated by the non-derangements
            non_derangements = [] # holds all non-derangement elements of G
            for c in self.G.conjugacy_classes: 
                if not Permutation(c.representative()).is_derangement():
                    for element in c:
                        non_derangements.append(element)
            H = PermutationGroup(non_derangements)
            non_der_common = Common(H)
            non_der_ekr = EKR_Determiner(non_der_common)
            #if non_der_ekr.has_ekr:
                #return 1
        return -1

    # HELPER FUNCTIONS

    def ub_larger_than_stabilizer_cocliques(G):
      if len(self.G.larger_than_stabilizer_cocliques) >= 1
         return (max([subgroup.order() for subgroup in self.G.larger_than_stabilizer_cocliques]))/(self.G.size_of_stabilizer)

    def ub_clique_coclique(G):
      largest_clique_size = -1 #initializing
      for subgroup in self.G.subgroups:
        subgroup_common = Common(subgroup)
          if subgroup_common.min_eigenvalue == -1 and subgroup_common.order > largest_clique_size:
            largest_clique_size = subgroup_common.order
      return G.order / largest_clique_size

    def ub_no_homomorphism(G):
      if G.minimally_transitive: return -1
      else:
        
         minimally_transitive_subgroups = [G for G in self.subgroups if G.] 

 
